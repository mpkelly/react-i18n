import e,{createContext as t,useContext as r,useState as n,useEffect as a,useCallback as o,forwardRef as s}from"react";const c=(e,t)=>{const r=[];let n;const a=RegExp(e,"g");for(;null!==(n=a.exec(t));)r.push({offsets:[n.index,n.index+n[0].length],array:n});return r},l=(e,t)=>e.match.offsets[0]-t.match.offsets[0],u=(e,t)=>{if(!t.length)return[e];const r=[],n=[];let a=e;if(t.forEach(e=>{c(e.pattern,a).forEach(t=>{const r=Array.from({length:t.array[0].length}).map(()=>" ").join("");a=a.replace(t.array[0],r),n.push({match:t,rule:e})})}),a===e)return[e];a=e;let o=0;return n.sort(l).forEach((e,t)=>{const[s,c]=e.match.offsets,l=a.substring(o,s);if(l&&r.push(l),r.push(e.rule.onMatch(e.match.array,t)),o=c,t+1===n.length){const e=a.substring(o);e&&r.push(e)}}),r},i={pattern:/(\*\*|__)(.*?)\1/,onMatch:(t,r)=>e.createElement("strong",{key:r},t[2])},h={pattern:/(\*|_)(.*?)\1/,onMatch:(t,r)=>e.createElement("em",{key:r},t[2])},f={pattern:/~~(.*?)~~/,onMatch:(t,r)=>e.createElement("del",{key:r},t[1])},m={pattern:/`(.*?)`/,onMatch:(t,r)=>e.createElement("code",{key:r},t[1])},p={pattern:/\[([^\[]+)\]\(([^\)]+)\)/,onMatch:(t,r)=>e.createElement("a",{key:r,href:t[2]},t[1])},g=[i,h,m,f,p],y=t(void 0),d=()=>r(y),b=t=>{const{bundles:r,children:s,markdownRules:c,lang:l}=t,u=d();let i,h,f={},m=[];u&&(f=u.bundle,i=u.lang,h=u.resolveLanguageBundle,m=u.markdownRules);const p=(c||[]).filter(e=>!m.includes(e)).concat(m),[g,b]=n(),E=l||i;if(!E)throw Error("No `lang` prop specified");a(()=>{b(void 0)},[l]);const w=o(e=>Promise.all([new Promise(t=>{f&&e===i?t(f):h?h(E).then(t):t({})}),new Promise(t=>{r&&r[e]?r[e]().then(t):t({})})]).then(e=>{let t={};return e.forEach(e=>{t=Object.assign(Object.assign({},t),e)}),t}),[E,i,f,r,h]);return a(()=>{g||w(E).then(b)},[g,E,f,r,w]),g?e.createElement(y.Provider,{value:{resolveLanguageBundle:w,lang:E,bundle:g,markdownRules:p}},s):null};function E(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(n=Object.getOwnPropertySymbols(e);a<n.length;a++)t.indexOf(n[a])<0&&Object.prototype.propertyIsEnumerable.call(e,n[a])&&(r[n[a]]=e[n[a]])}return r}function w(t){return s((r,n)=>{const a=O(r);return e.createElement(t,Object.assign({},a,{ref:n}))})}b.defaultProps={markdownRules:g};const O=e=>{let{i18n:t=""}=e,r=E(e,["i18n"]);if(!t)return e;const{bundle:n}=d();return j(t).forEach(e=>{const{args:t=[]}=e,a=E(e,["args"]),o=Object.keys(a)[0],s=n[e[o]];s&&(r[o]="string"==typeof s?s:s(...t))}),r},j=e=>"string"==typeof e?[{children:e}]:Array.isArray(e)?e:[e],k=(e,t,r)=>new Intl.DateTimeFormat(r,t).format(e),v=(e,t,r={style:"currency"},n)=>new Intl.NumberFormat(n,Object.assign(Object.assign({},r),{currency:t})).format(e),P=(e,t,r,n)=>{const a=new Intl.PluralRules(n).select(e);switch(a){case"one":return`${e} ${t}`;case"other":return`${e} ${r}`}throw Error(`Unable to match ${a}.`)};export{i as BoldRule,g as DefaultMarkdownRules,b as I18NProvider,m as InlineCodeRule,h as ItalicRule,p as LinkRule,f as StrikethroughRule,c as findRegex,v as formatCurrency,k as formatDate,P as pluralize,u as transform,d as useI18N,w as withI18N};
