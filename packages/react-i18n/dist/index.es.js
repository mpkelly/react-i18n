import e,{createContext as t,useContext as r,useState as n,useEffect as o,useCallback as a,forwardRef as s}from"react";const c=(e,t)=>{const r=[];let n;const o=RegExp(e,"g");for(;null!==(n=o.exec(t));)r.push({offsets:[n.index,n.index+n[0].length],array:n});return r},l=(e,t)=>e.match.offsets[0]-t.match.offsets[0],u=(e,t)=>{if(!t.length)return[e];const r=[],n=[];let o=e;if(t.forEach(e=>{c(e.pattern,o).forEach(t=>{const r=Array.from({length:t.array[0].length}).map(()=>" ").join("");o=o.replace(t.array[0],r),n.push({match:t,rule:e})})}),o===e)return[e];o=e;let a=0;return n.sort(l).forEach((e,t)=>{const[s,c]=e.match.offsets,l=o.substring(a,s);if(l&&r.push(l),r.push(e.rule.onMatch(e.match.array,t)),a=c,t+1===n.length){const e=o.substring(a);e&&r.push(e)}}),r},i={pattern:/(\*\*|__)(.*?)\1/,onMatch:(t,r)=>e.createElement("strong",{key:r},t[2])},f={pattern:/(\*|_)(.*?)\1/,onMatch:(t,r)=>e.createElement("em",{key:r},t[2])},h={pattern:/~~(.*?)~~/,onMatch:(t,r)=>e.createElement("del",{key:r},t[1])},p={pattern:/`(.*?)`/,onMatch:(t,r)=>e.createElement("code",{key:r},t[1])},m={pattern:/\[([^\[]+)\]\(([^\)]+)\)/,onMatch:(t,r)=>e.createElement("a",{key:r,href:t[2]},t[1])},g=[i,f,p,h,m],y=t(void 0),d=()=>r(y),b=t=>{const{bundles:r,children:s,markdownRules:c,lang:l}=t,u=d();let i,f,h={},p=[];u&&(h=u.bundle,i=u.lang,f=u.resolveLanguageBundle,p=u.markdownRules);const m=(c||[]).filter(e=>!p.includes(e)).concat(p),[g,b]=n(),O=l||i;if(!O)throw Error("No `lang` prop specified");o(()=>{b(void 0)},[l]);const E=a(e=>Promise.all([new Promise(t=>{h&&e===i?t(h):f?f(O).then(t):t({})}),new Promise(t=>{r&&r[e]?r[e]().then(w).then(t):t({})})]).then(e=>{let t={};return e.forEach(e=>{t=Object.assign(Object.assign({},t),e)}),t}),[O,i,h,r,f]);return o(()=>{g||E(O).then(b)},[g,O,h,r,E]),g?e.createElement(y.Provider,{value:{resolveLanguageBundle:E,lang:O,bundle:g,markdownRules:m}},s):null};b.defaultProps={markdownRules:g};const w=e=>{const t={};for(let r in e)if(e.hasOwnProperty(r))if("object"==typeof e[r]&&null!==e[r]){const n=w(e[r]);for(let e in n)n.hasOwnProperty(e)&&(t[r+"."+e]=n[e])}else t[r]=e[r];return t};function O(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(n=Object.getOwnPropertySymbols(e);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(e,n[o])&&(r[n[o]]=e[n[o]])}return r}function E(t){return s((r,n)=>{const o=j(r);return e.createElement(t,Object.assign({},o,{ref:n}))})}const j=e=>{let{i18n:t=""}=e,r=O(e,["i18n"]);if(!t)return e;const{bundle:n}=d();return P(t).forEach(e=>{const{args:t=[]}=e,o=O(e,["args"]),a=Object.keys(o)[0],s=n[e[a]];s&&(r[a]="string"==typeof s?s:s(...t))}),r},P=e=>"string"==typeof e?[{children:e}]:Array.isArray(e)?e:[e],k=(e,t,r)=>new Intl.DateTimeFormat(r,t).format(e),v=(e,t,r={style:"currency"},n)=>new Intl.NumberFormat(n,Object.assign(Object.assign({},r),{currency:t})).format(e),x=(e,t,r,n)=>{const o=new Intl.PluralRules(n).select(e);switch(o){case"one":return`${e} ${t}`;case"other":return`${e} ${r}`}throw Error(`Unable to match ${o}.`)};export{i as BoldRule,g as DefaultMarkdownRules,b as I18NProvider,p as InlineCodeRule,f as ItalicRule,m as LinkRule,h as StrikethroughRule,c as findRegex,v as formatCurrency,k as formatDate,x as pluralize,u as transform,d as useI18N,E as withI18N};
